package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"os"

	"github.com/rustyoz/svg"
)

var (
	flagIn  = flag.String("in", "", "name of svg file to read")
	flagOut = flag.String("out", "out.gcode", "name of gcode file to write")

	flagDX = flag.Float64("dx", 0, "where top-left of image is relative to pen start along x-axis (mm)")
	flagDY = flag.Float64("dy", 0, "where top-left of image is relative to pen start along y-axis (mm)")

	flagWidth  = flag.Float64("w", 0, "width of image (default: same as svg in mm, or proportional to -h)")
	flagHeight = flag.Float64("h", 0, "height of image (default: same as svg in mm, or proportional to -w)")
)

func parseSVG(name string) (*svg.Svg, error) {
	f, err := os.Open(name)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return svg.ParseSvgFromReader(f, "", 1.0)
}

type XForm struct {
	OB [4]float64
	NB [4]float64
}

func (xform *XForm) Transform(x, y float64) (float64, float64) {
	x -= xform.OB[0]
	x /= xform.OB[2] - xform.OB[0]
	x *= xform.NB[2] - xform.NB[0]
	x += xform.NB[0]

	y -= xform.OB[1]
	y /= xform.OB[3] - xform.OB[1]
	y *= xform.NB[3] - xform.NB[1]
	y += xform.NB[1]

	return x, y
}

var preamble = []string{
	"(generated by svgtocode, (c) Paul Hankin 2020)",
	"M3S40 (pen up)",
	"G21 (use mm)",
	"G90 (use absolute coords)",
	"G1F800 (g1 feed rate 800mm/min)",
}

var postamble = []string{
	"M3S50 (pen up)",
	"G0 X0Y0 (home)",
}

func outIns(w io.Writer, xform *XForm, ins *svg.DrawingInstruction) error {
	switch ins.Kind {
	case svg.LineInstruction:
		x, y := xform.Transform(ins.M[0], ins.M[1])
		fmt.Fprintf(w, "G1 X%.3f Y%.3f\n", x, y)
		return nil
	case svg.MoveInstruction:
		x, y := xform.Transform(ins.M[0], ins.M[1])
		fmt.Fprintf(w, "M3\nG4 P0.1\nG0 X%.3f Y%.3f\nM5\nG4 P0.1\n", x, y)
		return nil
	case svg.PaintInstruction:
		// issued at the end of every path
		return nil
	}
	return fmt.Errorf("unhandled instruction type %v", ins.Kind)
}

func main() {
	fail := func(s string, args ...interface{}) {
		fmt.Fprintf(os.Stderr, s+"\n", args...)
		os.Exit(2)
	}

	flag.Parse()
	if *flagIn == "" {
		fail("must specify -in <svg file>")
	}

	svgIn, err := parseSVG(*flagIn)
	if err != nil {
		fail("failed to parse svg: %v", err)
	}

	view, err := svgIn.ViewBoxValues()
	if err != nil {
		fail("failed to read viewbox values: %v", err)
	}
	ow := view[2] - view[0]
	oh := view[3] - view[1]
	if *flagWidth == 0 && *flagHeight == 0 {
		*flagWidth = ow
		*flagHeight = oh
	} else if *flagHeight == 0 {
		*flagHeight = *flagWidth * oh / ow
	} else if *flagWidth == 0 {
		*flagWidth = *flagHeight * ow / oh
	}

	xform := &XForm{
		OB: [4]float64{view[0], view[1], view[2], view[3]},
		NB: [4]float64{*flagDX, *flagDY, *flagWidth + *flagDX, *flagHeight + *flagDY},
	}

	gcodeOut, err := os.Create(*flagOut)
	if err != nil {
		fail("failed to open gcode output file: %v", err)
	}
	gcodeBuf := bufio.NewWriter(gcodeOut)

	for _, line := range preamble {
		if _, err := fmt.Fprintf(gcodeBuf, "%s\n", line); err != nil {
			fail("failed to write preamble: %v", err)
		}
	}

	dic, erc := svgIn.ParseDrawingInstructions()

	ddrain := false
	edrain := false
	for !ddrain || !edrain {
		select {
		case di, ok := <-dic:
			if !ok {
				dic = nil
				ddrain = true
				continue
			}
			if err := outIns(gcodeBuf, xform, di); err != nil {
				fail("gcode problem: %v", err)
			}
		case err, ok := <-erc:
			if !ok {
				edrain = true
				erc = nil
				continue
			}
			fail("svg parse failed: %v", err)
		}
	}

	for _, line := range postamble {
		if _, err := fmt.Fprintf(gcodeBuf, "%s\n", line); err != nil {
			fail("failed to write postamble: %v", err)
		}
	}

	if err := gcodeBuf.Flush(); err != nil {
		fail("failed to write gcode: %v", err)
	}

	if err := gcodeOut.Close(); err != nil {
		fail("failed to write gcode: %v", err)
	}
}
